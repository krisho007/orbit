// Orbit Multi-Tenant SaaS - Prisma Schema
// All models include userId for multi-tenancy isolation

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================
// NextAuth.js v5 Required Models
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  
  // User's own data
  contacts              Contact[]
  tags                  Tag[]
  conversations         Conversation[]
  events                Event[]
  relationships         Relationship[]
  relationshipTypes     RelationshipType[]
  
  @@map("users")
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// Core CRM Models
// ============================================

enum Gender {
  MALE
  FEMALE
}

model Contact {
  id                String    @id @default(cuid())
  userId            String
  displayName       String
  googleContactName String?   // Original name from Google import for re-import matching
  primaryPhone      String?
  primaryEmail      String?
  dateOfBirth       DateTime?
  gender            Gender?
  company           String?
  jobTitle          String?
  location          String?
  notes             String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  user                      User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  tags                      ContactTag[]
  conversationParticipants  ConversationParticipant[]
  eventParticipants         EventParticipant[]
  relationshipsFrom         Relationship[]             @relation("RelationshipFrom")
  relationshipsTo           Relationship[]             @relation("RelationshipTo")
  socialLinks               SocialLink[]
  images                    ContactImage[]

  @@index([userId])
  @@index([userId, displayName])
  @@index([userId, googleContactName])
  @@map("contacts")
}

model Tag {
  id        String   @id @default(cuid())
  userId    String
  name      String
  color     String?  @default("#3B82F6")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  contacts ContactTag[]

  @@unique([userId, name])
  @@index([userId])
  @@map("tags")
}

model ContactTag {
  id        String   @id @default(cuid())
  contactId String
  tagId     String
  createdAt DateTime @default(now())

  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([contactId, tagId])
  @@index([contactId])
  @@index([tagId])
  @@map("contact_tags")
}

// ============================================
// Conversation Models
// ============================================

enum ConversationMedium {
  PHONE_CALL
  WHATSAPP
  EMAIL
  CHANCE_ENCOUNTER
  ONLINE_MEETING
  IN_PERSON_MEETING
  OTHER
}

model Conversation {
  id         String             @id @default(cuid())
  userId     String
  content    String?
  medium     ConversationMedium
  happenedAt DateTime
  followUpAt DateTime?
  eventId    String?
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt

  user         User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  event        Event?                     @relation(fields: [eventId], references: [id], onDelete: SetNull)
  participants ConversationParticipant[]

  @@index([userId])
  @@index([userId, happenedAt])
  @@index([eventId])
  @@map("conversations")
}

model ConversationParticipant {
  id             String   @id @default(cuid())
  conversationId String
  contactId      String
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  contact      Contact      @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([conversationId, contactId])
  @@index([conversationId])
  @@index([contactId])
  @@map("conversation_participants")
}

// ============================================
// Event Models
// ============================================

enum EventType {
  MEETING
  CALL
  BIRTHDAY
  ANNIVERSARY
  CONFERENCE
  SOCIAL
  OTHER
}

model Event {
  id          String    @id @default(cuid())
  userId      String
  title       String
  description String?
  eventType   EventType
  startAt     DateTime
  endAt       DateTime?
  location    String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  participants  EventParticipant[]
  conversations Conversation[]

  @@index([userId])
  @@index([userId, startAt])
  @@map("events")
}

model EventParticipant {
  id        String   @id @default(cuid())
  eventId   String
  contactId String
  createdAt DateTime @default(now())

  event   Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([eventId, contactId])
  @@index([eventId])
  @@index([contactId])
  @@map("event_participants")
}

// ============================================
// Relationship Models
// ============================================

model RelationshipType {
  id                    String   @id @default(cuid())
  userId                String
  name                  String   // e.g., "Father", "Son", "Spouse"
  reverseTypeId         String?  // Points to the inverse type (Father -> Son)
  maleReverseTypeId     String?  // Gender-specific reverse for male (Parent -> Son)
  femaleReverseTypeId   String?  // Gender-specific reverse for female (Parent -> Daughter)
  isSymmetric           Boolean  @default(false) // True for Spouse, Friend, Sibling
  isSystem              Boolean  @default(false) // True for default types that can't be deleted
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user                  User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  reverseType           RelationshipType?  @relation("ReverseRelation", fields: [reverseTypeId], references: [id], onDelete: SetNull)
  reverseOf             RelationshipType[] @relation("ReverseRelation")
  maleReverseType       RelationshipType?  @relation("MaleReverseRelation", fields: [maleReverseTypeId], references: [id], onDelete: SetNull)
  maleReverseOf         RelationshipType[] @relation("MaleReverseRelation")
  femaleReverseType     RelationshipType?  @relation("FemaleReverseRelation", fields: [femaleReverseTypeId], references: [id], onDelete: SetNull)
  femaleReverseOf       RelationshipType[] @relation("FemaleReverseRelation")
  relationships         Relationship[]

  @@unique([userId, name])
  @@index([userId])
  @@map("relationship_types")
}

model Relationship {
  id            String   @id @default(cuid())
  userId        String
  fromContactId String
  toContactId   String
  typeId        String
  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  fromContact Contact          @relation("RelationshipFrom", fields: [fromContactId], references: [id], onDelete: Cascade)
  toContact   Contact          @relation("RelationshipTo", fields: [toContactId], references: [id], onDelete: Cascade)
  type        RelationshipType @relation(fields: [typeId], references: [id], onDelete: Cascade)

  @@unique([fromContactId, toContactId, typeId])
  @@index([userId])
  @@index([fromContactId])
  @@index([toContactId])
  @@index([typeId])
  @@map("relationships")
}

// ============================================
// Social Links & Images
// ============================================

model SocialLink {
  id        String   @id @default(cuid())
  contactId String
  platform  String   // e.g., "LinkedIn", "Facebook", "Website", "Twitter"
  url       String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@index([contactId])
  @@map("social_links")
}

model ContactImage {
  id        String   @id @default(cuid())
  contactId String
  imageUrl  String
  publicId  String?  // Supabase storage path or identifier
  order     Int      @default(0)
  createdAt DateTime @default(now())

  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@index([contactId])
  @@map("contact_images")
}
